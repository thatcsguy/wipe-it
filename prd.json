{
  "project": "Agent-Friendly Testing Infrastructure",
  "description": "Add DOM-accessible debug panel, toast notifications, and event-based APIs to enable Playwright-based testing without canvas evaluation",
  "items": [
    {
      "id": "DEBUG-001",
      "category": "Debug Panel",
      "description": "Create debug panel container in HTML that is hidden by default and shown when URL contains ?debug=1 query parameter. Add <div id=\"debug-panel\" class=\"debug-panel\"> to index.html. Panel should be positioned fixed on the right side of the screen, not overlapping the canvas.",
      "steps_to_verify": [
        "Open browser to http://localhost:3000 - debug panel should NOT be visible",
        "Open browser to http://localhost:3000?debug=1 - debug panel SHOULD be visible",
        "Use Playwright: await page.goto('http://localhost:3000?debug=1'); await expect(page.locator('#debug-panel')).toBeVisible()",
        "Use Playwright: await page.goto('http://localhost:3000'); await expect(page.locator('#debug-panel')).not.toBeVisible()"
      ],
      "passes": true
    },
    {
      "id": "DEBUG-002",
      "category": "Debug Panel",
      "description": "Create src/client/debugPanel.ts module that exports initDebugPanel() and updateDebugPanel(gameState, localPlayerId) functions. initDebugPanel() should check for ?debug=1 and set up the panel structure. updateDebugPanel() should be called each frame from the game loop in game.ts to refresh displayed data.",
      "steps_to_verify": [
        "File src/client/debugPanel.ts exists",
        "Module exports initDebugPanel and updateDebugPanel functions",
        "initDebugPanel is called from main.ts or game.ts on startup",
        "updateDebugPanel is called in the game loop in game.ts"
      ],
      "passes": true
    },
    {
      "id": "DEBUG-003",
      "category": "Debug Panel",
      "description": "Debug panel displays all connected players with data attributes. Each player shown as <div class=\"debug-player\" data-player-id=\"{id}\" data-hp=\"{hp}\" data-x=\"{x}\" data-y=\"{y}\">{name}: {hp}HP</div>. Values must update in real-time as game state changes. Include visual health bar inside each player div.",
      "steps_to_verify": [
        "Join game with ?debug=1, verify your player appears in debug panel",
        "Use Playwright: const player = page.locator('.debug-player').first(); await expect(player).toHaveAttribute('data-hp', /\\d+/)",
        "Use Playwright: verify data-x and data-y attributes update when player moves using WASD",
        "Take damage from a mechanic, verify data-hp attribute decreases",
        "Health bar visual width should correspond to HP percentage"
      ],
      "passes": true
    },
    {
      "id": "DEBUG-004",
      "category": "Debug Panel",
      "description": "Debug panel displays all active mechanics with data attributes. Each mechanic shown as <div class=\"debug-mechanic\" data-mechanic-id=\"{id}\" data-type=\"{type}\" data-expires=\"{expiresAt}\">{type} - expires {timeRemaining}ms</div>. Mechanics should be added when spawned and removed when resolved/expired.",
      "steps_to_verify": [
        "Join game with ?debug=1, click 'Spawn Chariot' admin button",
        "Verify mechanic appears in debug panel with data-type=\"chariot\"",
        "Use Playwright: await page.click('#spawn-chariot-btn'); await expect(page.locator('.debug-mechanic[data-type=\"chariot\"]')).toBeVisible()",
        "Wait 3 seconds, verify mechanic element is removed from debug panel",
        "Use Playwright: await expect(page.locator('.debug-mechanic[data-type=\"chariot\"]')).not.toBeVisible({ timeout: 5000 })"
      ],
      "passes": true
    },
    {
      "id": "DEBUG-005",
      "category": "Debug Panel",
      "description": "Debug panel displays status effects per player. Within each .debug-player div, show status effects as <span class=\"debug-status\" data-effect=\"{effectType}\">{effectType}</span>. Status effects appear when applied and disappear when expired.",
      "steps_to_verify": [
        "Join game with ?debug=1 and another player",
        "Spawn spreads, have players overlap to trigger vulnerability",
        "Verify data-effect=\"vulnerability\" span appears inside affected player's debug-player div",
        "Use Playwright: await expect(page.locator('.debug-player .debug-status[data-effect=\"vulnerability\"]')).toBeVisible()",
        "Wait for effect to expire, verify span is removed"
      ],
      "passes": false
    },
    {
      "id": "TOAST-001",
      "category": "Toast System",
      "description": "Create toast notification container in HTML. Add <div id=\"action-log\" class=\"action-log\"></div> to index.html. Position fixed at bottom-left or bottom-center of screen, above any UI elements. Should always be visible (not dependent on debug mode).",
      "steps_to_verify": [
        "Open browser to http://localhost:3000",
        "Verify #action-log element exists in DOM (can be empty)",
        "Use Playwright: await expect(page.locator('#action-log')).toBeAttached()"
      ],
      "passes": true
    },
    {
      "id": "TOAST-002",
      "category": "Toast System",
      "description": "Create src/client/toast.ts module that exports showToast(message: string) function. Each call appends <div class=\"toast\">{message}</div> to #action-log. Toast should auto-remove after 3 seconds. Maximum 5 toasts visible at once (oldest removed first if exceeded).",
      "steps_to_verify": [
        "File src/client/toast.ts exists",
        "Module exports showToast function",
        "Calling showToast('Test') adds a .toast element with text 'Test'",
        "After 3 seconds, the toast element is removed from DOM",
        "Adding 6 toasts rapidly results in only 5 being visible"
      ],
      "passes": true
    },
    {
      "id": "TOAST-003",
      "category": "Toast System",
      "description": "Admin actions trigger toast notifications. Modify src/client/admin.ts to call showToast() after each admin emit. Messages: 'Spawned chariot' for chariot, 'Spawned spreads' for spreads, 'Healed all players' for heal all, 'Changed name to {name}' for name change.",
      "steps_to_verify": [
        "Click 'Spawn Chariot' button, verify toast 'Spawned chariot' appears",
        "Click 'Spawn Spreads' button, verify toast 'Spawned spreads' appears",
        "Click 'Heal All' button, verify toast 'Healed all players' appears",
        "Use Playwright: await page.click('#heal-all-btn'); await expect(page.locator('.toast', { hasText: 'Healed all players' })).toBeVisible()",
        "Use Playwright: await page.click('#spawn-chariot-btn'); await expect(page.locator('.toast', { hasText: 'Spawned chariot' })).toBeVisible()"
      ],
      "passes": true
    },
    {
      "id": "TOAST-004",
      "category": "Toast System",
      "description": "Style toast notifications with CSS in public/css/style.css. Toasts should have visible background color, padding, border-radius, and fade-out animation before removal. Action log container should not interfere with game interaction.",
      "steps_to_verify": [
        "Toasts are visually distinct from background (contrasting color)",
        "Toasts have padding and rounded corners",
        "Toasts animate out (fade or slide) before removal",
        "Can still click on canvas and admin buttons with toasts visible"
      ],
      "passes": false
    },
    {
      "id": "EVENT-001",
      "category": "Event API",
      "description": "Add onStateChange(callback) to __gameTest API in src/client/game.ts. Callback receives full GameState on every state update from server. Returns unsubscribe function. Multiple callbacks can be registered.",
      "steps_to_verify": [
        "Use browser console: let count = 0; __gameTest.onStateChange(() => count++); then verify count increases over time",
        "Verify callback receives GameState object with players, mechanics, statusEffects, timestamp",
        "Verify unsubscribe function stops callbacks: const unsub = __gameTest.onStateChange(cb); unsub(); verify cb no longer called",
        "Use Playwright: await page.evaluate(() => new Promise(resolve => { __gameTest.onStateChange(state => { if(state.players.length > 0) resolve(true); }); }))"
      ],
      "passes": true
    },
    {
      "id": "EVENT-002",
      "category": "Event API",
      "description": "Add onMechanicSpawn(callback) to __gameTest API. Callback fires when a new mechanic appears in game state (not present in previous state). Callback receives the new MechanicState object. Returns unsubscribe function.",
      "steps_to_verify": [
        "Register callback, click 'Spawn Chariot', verify callback fires with mechanic data",
        "Verify callback receives object with id, type, x, y, radius, expiresAt properties",
        "Use Playwright: await page.evaluate(() => new Promise(resolve => { __gameTest.onMechanicSpawn(m => resolve(m)); })); await page.click('#spawn-chariot-btn'); verify promise resolves with mechanic",
        "Verify callback does not fire for mechanics already present (only new ones)"
      ],
      "passes": false
    },
    {
      "id": "EVENT-003",
      "category": "Event API",
      "description": "Add onMechanicResolve(callback) to __gameTest API. Callback fires when a mechanic disappears from game state (was present, now gone). Callback receives the mechanic id that resolved. Returns unsubscribe function.",
      "steps_to_verify": [
        "Register callback, spawn chariot, wait for expiration, verify callback fires",
        "Verify callback receives the mechanic id string",
        "Use Playwright: spawn mechanic, then await page.evaluate(() => new Promise(resolve => { __gameTest.onMechanicResolve(id => resolve(id)); })); verify resolves after ~3 seconds"
      ],
      "passes": false
    },
    {
      "id": "EVENT-004",
      "category": "Event API",
      "description": "Add waitForMechanicResolve(mechanicId) to __gameTest API. Returns a Promise that resolves when the specified mechanic is no longer in game state. If mechanic doesn't exist, resolve immediately. Useful for tests that need to wait for mechanic completion.",
      "steps_to_verify": [
        "Spawn chariot, get its id, call waitForMechanicResolve(id), verify promise resolves after ~3 seconds",
        "Call waitForMechanicResolve('nonexistent'), verify resolves immediately",
        "Use Playwright: await page.evaluate(async () => { const state = __gameTest.getGameState(); const id = state.mechanics[0]?.id; if(id) await __gameTest.waitForMechanicResolve(id); return true; })"
      ],
      "passes": false
    },
    {
      "id": "STYLE-001",
      "category": "Styling",
      "description": "Add CSS styles for debug panel in public/css/style.css. Panel should be fixed position on right side, dark semi-transparent background, light text, scrollable if content overflows. Should not block canvas interaction. Health bars should be colored (green to red gradient based on HP).",
      "steps_to_verify": [
        "Debug panel is positioned on right side of screen",
        "Panel has dark background with readable light text",
        "Panel scrolls if many players/mechanics present",
        "Canvas is still clickable/interactable",
        "Health bars show color gradient (green=full, red=low)"
      ],
      "passes": false
    },
    {
      "id": "INTEGRATION-001",
      "category": "Integration",
      "description": "Ensure debug panel and toast system work together without conflicts. Both should initialize on page load. Debug panel controlled by query param, toasts always active. No console errors during normal gameplay with both systems active.",
      "steps_to_verify": [
        "Load game with ?debug=1, perform admin actions, verify both debug panel updates and toasts appear",
        "Check browser console for errors during 30 seconds of gameplay",
        "Use Playwright: navigate with debug=1, spawn mechanics, heal, verify no console errors logged"
      ],
      "passes": false
    },
    {
      "id": "INTEGRATION-002",
      "category": "Integration",
      "description": "Expose debug panel functions on window for testing. Add __debugTest object with show(), hide(), isVisible(), and getElement() methods. Allows programmatic control of debug panel visibility regardless of query param.",
      "steps_to_verify": [
        "window.__debugTest exists after page load",
        "__debugTest.show() makes panel visible even without ?debug=1",
        "__debugTest.hide() hides panel",
        "__debugTest.isVisible() returns correct boolean",
        "__debugTest.getElement() returns the #debug-panel DOM element"
      ],
      "passes": false
    }
  ]
}
